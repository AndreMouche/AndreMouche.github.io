---
layout: post
title: "[译文 I]Spanner:Google's Globally-Distributed Database"
keywords: ["Spanner"]
description: "[译文 I]Spanner:Google's Globally-Distributed Database"
category: "spanner"
tags: ["Spanner","Google"]
comments: true
---
# [译文I]Spanner:Google's Globally-Distributed Database

## 原文
[Spanner:Google's Globally-Distributed Database](http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf)

## 译文结构

* [摘要、介绍](#)
* Implementation(TODO)
* TODO

## 摘要

Spanner是由Google研发的数据库，特性如下：

* 可扩展
* 多版本支持
* 全球分布式
* 支持同步复制

它是第一个把数据分布在全球范围内，并支持外部一致性的分布式事物。
本文将介绍以下内容：

* Spanner的架构设计
* Spanner特性功能集
* 多种设计决策其背后的原理
* 一个可暴露时间不确定性的全新的时间API。该API及其实现是支持外部一致性和很多强大的特性的关键。这些强大的特效包括Spanner里面所有涉及到的以下几点的实现：
1. 对旧数据的非阻塞读（多个事物并发进行时触发）
2. 无锁只读事物
3. 原子模式的变更（ddl原子性）

### 介绍

Spanner是一个可扩展，全球分布式数据库，它在Google公司设计、开发部署、和发布。抽象到最高层，首先它是一个数据库，该数据库将数据分布在很多由Paxos[21]状态机组成的集群中，这些机器遍布全球各数据中心。复制技术用来服务于全球可用性和地理局部性；客户端会自动在副本间处理failover。当数据的量或服务器的个数发生变化时，Spanner会自动在机器间重新分片（reshard),同时为有效应对负载均衡和失败处理，它自动在机器甚至数据中心间迁移数据。Spanner被设计成可扩展到百万级别的机器上，分布上百个数据中心，可达万亿行级别的数据规模。

**应用使用Spanner可以实现高可用**：甚至在面对强大的自然灾害面前，通过在一个州甚至跨州的数据复制，保证其依然可用。我们最初的服务客户是F1［34］－－Google广告后台系统的一个重新实现。F1使用了跨全美国的五个副本。然而其它大部分应用可能只需要在一个地理范围内跨3-5个数据中心放置副本，且使用相对独立的失败模式。也就是说，大部分应用会优先选择低延时，然后才是高可用－－只要保证能在1-2个数据中心失败时依旧能恢复。

**Spanner重点关注于跨数据中心的数据副本管理，同时在基于我们的分布式架构上设计并实现数据库的很多重要特性上，也花了不少精力。**虽然很多项目可以愉快地使用Bigtable[9],我们还是会持续收到很多来自Bigtagble使用者的抱怨，Bigtable在一些类型的应用中十分难用：如有些包含复杂、可变模式，或那些对跨区域的多副本间有很强的一致性要求（其它作者也发出了类似的抱怨[37]）。Google的很多应用已经选择使用了Megastore[5],因为其半关系型数据模型，以及对同步复制的支持，虽然这玩意儿的写吞吐量相对较小。因此，Spanner已由一个类BigTable的版本键值存储，演变为一个带时间属性的多版本数据库：

* 数据被存放于规范的半关系表中；
* 数据版本化，且每个版本都被自动打上其提交时的时间戳；
* 旧版本的数据受制于配置化的垃圾回收策略；
* 应用可以读取旧时间戳的数据
* Spanner支持通用事物，且提供了基于SQL的查询语言

作为一个全球分布式数据库，Spanner提供了一些有趣的特性：

**首先，在副本配置上，应用在更细粒度上进行动态控制。** 应用可以特定控制以下内容

1. 哪些数据中心放哪些数据;
2. 数据跟用户的距离（控制读延时）;
3. 副本间的距离（控制写延时）；
4. 维护多少副本（控制持久性，可用性，读性能）

同时，为平衡各数据中心间的资源使用，数据也可以在数据中心间被动态透明地移动

第二，Spanner有两个分布式数据库难以实现的功能：

1. 外部一致性读和写操作
2. 同一时间戳数据库的全局一致性读操作。

这些特性使得Spanner在全局范围内，即使存在正在处理的事务时，也能做到：

* 支持一致性备份，
* 一致性mapreduce运算[12]
* schema变更的原子性。
 
 
Spanner的以上特性得以实现，归功于Spanner为事务指定了全局意义的提交时间戳，即使事务也可能是分布式的。该时间戳反映出序列化顺序。此外，该序列化顺序满足了外部一致性（等价于线性一致性[20]）:如果一个事物T1提交于另一个事务T2开始前，那么T1的提交时间戳小于T2的。Spanner 是在全局范围内提供这种保证的第一个系统。

成就这些特性的关键是一个全新的真实时间API（new TrueTime API）及其实现。该API直接暴露了时钟的不确定性，Spanner时间戳的保障基于该实现所提供的界限。如果这个不确定性很大，Spanner则放慢速度以等待该不确定性。Google的集群管理软件提供了该TrueTimeAPI的一个实现，其实现通过使用多个现代时钟作为参考（GPS和原子钟），将不确定性保持到很小（一般小于10ms）

本文结构简介：

* 第二章将介绍Spanner实现的架构、特性集、以及在设计过程中涉及到的一些工程决策。
* 第三章将介绍新的时间API（new TrueTime API） 并概述其实现。
* 第四章将介绍Spanner如何使用TrueTime实现外部一致性分布式事务，无锁只读事务，原子schema更新。
* 第五章提供了一些Spanner性能的一些benchmarks,时间行为，并讨论F1的实践。
* 第六、七、八章讨论相关工作，将来的工作，总结。   




