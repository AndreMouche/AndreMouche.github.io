---
layout: post
title: "Nginx介绍(译文II)"
keywords: ["nginx"]
description: "nginx"
category: "nginx"
tags: ["nginx"]

---


##Nginx 介绍（译文II）

* 原文 [nginx](http://www.aosabook.org/en/nginx.html)
* 作者 [Andrew Alexeev](http://www.aosabook.org/en/intro2.html#alexeev-andrew)

<ul>
<li><a href="#Nginx架构综述">Nginx架构综述</a></li>
<ul>
<div>
<li><a href="#代码结构">代码结构</a></li>
<li><a href="#Worker模型">Worker模型</a></li>
</ul>
</ul>



##Nginx架构综述

使用单独的线程或进程处理每个连接,是基于线程或进程处理并发连接的传统做法。

* 该做法往往会阻塞于网络和I/O操作。
* 对于不同的应用，这种做法可能会使内存和CPU消耗变得非常低效。
* 创建一个新的进程或线程需要准备新的运行环境，包括在内存中分配新的堆栈、新的运行上下文。
在创建这些过程中，必然会产生额外的CPU时间，而这种运行上下文切换引起的线程抖动最终将造成性能低下。

以上的这些并发症几乎存在于所有在如Apache这样的老旧网站服务架构中。因此，我们往往需要在丰富的通用特性集和优化服务器资源之间权衡利弊。

早期的nginx为了做一个专注于为**动态扩展网站**提供

* 更高性能
* 高密度
* 更有效

 的使用服务器资源的专业工具，因此使用了不一样的模型。
 
 实际上，随着各操作系统上的高级事件驱动开发的发展，使得一个
 
 * 模块化
 * 事件驱动
 * 异步
 * 单线程
 * 无阻塞架构
 
成为了nginx源码的基础。

Nginx主要使用了**多路复用**与**事件通知**方式，将各个任务分发给各个特定进程。所有的请求连接由数量有限的进程（被称为worker）处理，各个worker使用一个高效的单线程循环处理，每个worer进程每秒可处理上千个并发和请求。

###代码结构

Nginx worker的代码包含**核心**和**功能模块**。

* 核心负责维护一个严谨的处理循环，并且在请求处理的每个阶段执行对应的代码模块。
* 模块负责大部分展示和应用层功能，包括从网络和存储设备读取、写入，内容转换、执行输出过滤，执行服务端嵌入（SSI）操作、以及在启用代理时转发请求给后端服务器。

得益于nginx模块化的架构，开发者可以在无需修改核心的基础上，对服务器的功能进行扩展。Nginx的典型模块并不多，分别是：

* 核心模块
* 事件模块
* 阶段处理器
* 协议、变量处理器
* 过滤器
* 上游和负载均衡器

目前，nginx并不支持动态加载模块，即模块代码是在编译核心代码时一起编译的。然而，动态加载模块和ABI已列入未来主要发布版本计划中。各个模块角色的详细信息可查看后面的nginx Internals。

Nginx通过使用事件通知机制和一系列提高IO的工具(在Linux、Solaris和基于BSD的操作系统上使用kqueue、epoll和event ports等技术)，来处理大量操作如接受、处理和管理连接、检索内容。其目的在于尽可能的提示操作系统，对进出流量，磁盘操作，套接字读写操作，超时等事件及时异步地获取反馈。其中，多路复用与高级I/O操作的各种方式，对每个基于Unix操作系统运行的nginx都做了高度的优化。

图14.1展示了nginx架构的整体设计。
<img src="/images/nginx-architecture.png" alt="NAT" title="Host-only adapter" width="600" />

nginx-architecture.png-nginx架构图

###Worker模型

如前面提到的，**nginx不会为每个连接创建新的进程或线程**。而是由worker进程各自通过共享“监听”socket来接收新请求，同时每个worker内部会使用一个高效的处理循环来处理上千个连接。在Nginx中，不存在特定的仲裁器或分发器用以分发连接给各个worker，这个工作由操作系统内核机制完成。服务启动时，一组监听socket被创建并完成初始化，workers进程不断地从这些套接字接受、读取HTTP请求和输出响应。

**事件处理循环是nginx worker代码中最复杂的部分，它包含了全面的内部调用，并且高度依赖异步任务处理的思想**。异步操作通过

* 模块化
* 事件通知
* 大量使用回调函数
* 高度调优的定时器

等实现。

总之，关键原则就是**尽可能做到非阻塞**。目前唯一还会引起Nginx阻塞的条件是woker的磁盘性能不足。

* 由于nginx不为每个连接创建新进程或线程，故内存使用在大多场景中是传统并高效的。
* 同时由于不用频繁创建－销毁进程或线程，nginx也很节省CPU时间。
* Nginx所做的就是检查网络和存储的状态，初始化新连接、将其添加到主循环，异步处理直到完成，而后才从主循环中释放并删除。
* 结合精心设计的系统调用、优雅实现诸如内存池等支持接口，nginx基本能够做到中低CPU使用率，即使在极端负载的情况下也不例外。

 **因为nginx创建了多个worker进程来处理连接，所以能够很好的利用多核CPU。**通常一核一worker便能完全利用多核体系架构，并能够优雅的避免线程抖动与锁。这是因为在一个单线程？的worker进程内部不存在资源匮乏，并且资源控制机制也能很好的隔离。此外这个模型也允许
 
 * 在物理存储设备之间进行扩展
 * 提高磁盘利用率
 * 避免磁盘I/O导致的阻塞
 
 总之，这种将工作负载分布到多个worker进程上的方式，最终能使服务器资源被更高效的利用。

**nginx worker进程数应根据具体的磁盘使用和CPU负载的模式进行调整**。具体实施方法比较简单，系统管理员往往是根据具体负载情况进行多次配置项的尝试。一般会推荐如下做法：

* 如果负载模式是CPU密集型－－如处理大量的TCP/IP协议，使用SSL，或者压缩数据－－那么nginx worker进程数与CPU核数相当；
* 如果是磁盘密集型－－如从存储磁盘中读取多样化内容给客户端的服务，或包含大量的代理服务－－此时worker的进程数应该是CPU核数的1.5～2倍。

一些工程师会基于独立存储单元的个数来选择worker进程数，然而该方法的有效性会受到磁盘存储类型和配置的影响。

**解决如何避免由磁盘I/O引起的大部分阻塞，**是Nginx开发者在未来版本中需要解决的主要问题之一。目前，针对某个woker的磁盘操作,如果没有足够的存储性能为其服务，该进程就可能会一直阻塞在磁盘读写操作上。当然，存在多种机制和配置指令文件用于缓解这类磁盘I/O阻塞的场景，典型的做法如结合一些像sendfile和异步IO指令，便可以为磁盘操作节省大量的空间。同时，在nginx的安装过程中，也应将数据集，可用内存数，以及底层存储架构来规划在内。

**对嵌入脚本的支持有限**，是当前的worker模型存在的另一个问题。例如，标准的nginx发布版本只支持Perl作为嵌入脚本语言。原因很简单：关键是嵌入脚本很可能会在任何操作上阻塞或者异常退出，而这两个行为都会直接导致worker进程挂住而同时影响数千个连接。与此相关的更多工作已列入Nginx开发计划，即将脚本更简单，更可靠地嵌入nginx并且更适合广泛应用。

